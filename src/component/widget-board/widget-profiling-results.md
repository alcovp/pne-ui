По двум профайлам картина консистентная: тормоза при drag/resize — это в первую очередь **загрузка main thread из‑за JS/React (частые тяжёлые рендеры/коммиты во время перетаскивания)**, а не «чисто CSS/paint».

## Что подтверждает React Profiler (profiling-data…json)

1. **Drag/resize запускает state update прямо из drag-хэндла**
   В `schedulingEvents` видно `schedule-state-update` от `DragHandleWrapper` (lane `4`). Это означает, что во время взаимодействия вы реально «дергаете» React‑состояние и тем самым запускаете рендер/коммит.

2. **Коммиты во время взаимодействия сильно выше бюджета кадра (16.7ms)**
   Есть серии коммитов порядка **60–65ms**, а также пики до **~98ms** (в файле это явно встречается). Например: `duration: 60.1`, `duration: 65.1`, `duration: 98`.

3. **Рендерится не только “драг-оверлей”, а заметная часть доски/грида**
   В `snapshots` видно, что `InternalBoard` — отдельный компонент дерева (`id: 12109`).
   А в одном из тяжёлых коммитов в `fiberActualDurations` прямо видно, что большие значения приходятся на:

* `InternalBoard` (~65ms)
* `Grid` (~64.7ms)
* и на конкретный `GridItem/ItemContainerComponent` “heavy‑5” (~27–28ms)


То есть во время drag/resize вы фактически заставляете React «прожёвывать» **весь Grid/Board** + ещё и содержимое тяжёлого виджета.

4. **Существенная добавка времени уходит в effects после коммита**
   В timeline видно, что после рендера идут `commit / layout-effects / passive-effects`, причём `passive-effects` может быть двузначным числом миллисекунд (пример: ~13ms).
   Также есть коммиты, где `passiveEffectDuration` заметный (например 17.1).
   Это означает: даже если рендер оптимизировать, **эффекты** тоже могут продолжать «съедать» кадр во время перетаскивания.

5. **Memo(GridItem) сам по себе не спасает**
   В логе много событий по `Memo(GridItem)`/`Placeholder` (пусть и с маленькими длительностями на элемент), то есть обновления идут пачкой.

## Что показывает Chrome Performance trace (Trace-…json)

По самому trace (участок ~1.65s между `pointerdown` и `pointerup`) видно следующее на main thread:

* Main thread почти непрерывно занят задачами; есть **long tasks порядка ~110–256ms** в процессе drag.
* Самый большой вклад — **Scripting/JS** (внутри это выглядит как большие куски выполнения JS), а **layout/paint суммарно существенно меньше** и не выглядит главным ограничителем.

Итого по trace: лаг — это не «GPU не успевает рисовать», а **main thread блокируется крупными порциями JS**, из‑за чего кадры пропускаются.

## Общее заключение (root cause)

Лаги при drag/resize происходят потому что взаимодействие реализовано как **частая реактовая перерисовка (state update → render/commit) большого поддерева (`InternalBoard`/`Grid`/много `GridItem`)**, причём вместе с этим перерендеривается и **контент тяжёлого виджета** (“heavy‑5”), плюс дополнительно добивают **passive effects** после коммитов. Это гарантированно даёт «рваный» drag, потому что вы регулярно превышаете бюджет 16ms на кадр (в профайле это 60–98ms).

## Практический смысл для фикса (коротко, приоритетно)

1. **Отвязать позиционирование при drag/resize от React-рендера на каждый move**
   Идеал: во время движения менять только `transform` (через `requestAnimationFrame` + `ref`/imperative update), а React‑state/пересчёт сетки — **реже** (например, throttling) или **только на drop**.

2. **“Облегчить” то, что рендерится во время drag**
   На время drag показывать упрощённый preview/placeholder вместо полного содержимого виджета (особенно для “heavy” контента). Это прямо уберёт ~десятки миллисекунд из `GridItem/ItemContainerComponent`.

3. **Проверить, почему обновляется весь `InternalBoard/Grid`, и сузить область обновления**
   Частая причина: общий context/props меняются и ломают мемоизацию всех детей. Цель: чтобы при drag менялись данные **только одного айтема** (и то — в идеале без React), а остальные не получали новые props/context.

4. **Выключить/отложить тяжёлые passive effects на время drag**
   Если эффекты (аналитика, observers, пересчёты) запускаются на каждый коммит — их нужно либо батчить, либо условно отключать на период drag.

Если нужно, могу:

* выписать топ‑поддеревья по `fiberSelfDurations`/`fiberActualDurations` для самых тяжёлых коммитов и дать конкретный список “что именно перерисовывается лишнее”;
* предложить конкретный паттерн (overlay + transform + commit on drop) под текущую структуру `InternalBoard/GridItem/DragHandleWrapper`.
